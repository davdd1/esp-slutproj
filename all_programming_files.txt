

================================================================================
File: .\collect_files.py
================================================================================

import os
import argparse

def main():
    parser = argparse.ArgumentParser(description='Concatenate all programming files into a single text file.')
    parser.add_argument('-d', '--directory', default='.', help='Root directory to scan')
    parser.add_argument('-o', '--output', default='all_programming_files.txt', help='Output file name')
    parser.add_argument('-e', '--extensions', nargs='+', help='List of file extensions to include', default=[
        '.py', '.java', '.c', '.cpp', '.h', '.js', '.rb', '.php', '.go', '.cs', '.swift', '.kt',
        '.html', '.css', '.ts', '.sql', '.json', '.xml', '.sh', '.pl', '.r', '.m', '.erl', '.ex',
        '.exs', '.scala', '.lhs', '.hs', '.ml', '.fs', '.fsx'
    ])
    parser.add_argument('-x', '--exclude', nargs='+', help='List of file extensions to exclude', default=[])

    args = parser.parse_args()

    programming_extensions = args.extensions
    exclude_extensions = args.exclude
    output_file = args.output
    root_dir = args.directory

    # Define directories to ignore
    ignore_dirs = {'.vscode', '.devcontainer', 'build'}

    with open(output_file, 'w', encoding='utf-8') as outfile:
        for dirpath, dirnames, filenames in os.walk(root_dir):
            # Modify dirnames in-place to skip ignored directories
            dirnames[:] = [d for d in dirnames if d not in ignore_dirs]

            for filename in filenames:
                # Check if file has an allowed extension and is not in the exclude list
                if (any(filename.endswith(ext) for ext in programming_extensions) and
                    not any(filename.endswith(ext) for ext in exclude_extensions)):
                    file_path = os.path.join(dirpath, filename)
                    try:
                        with open(file_path, 'r', encoding='utf-8') as infile:
                            content = infile.read()
                        outfile.write(f"\n\n{'='*80}\n")
                        outfile.write(f"File: {file_path}\n")
                        outfile.write(f"{'='*80}\n\n")
                        outfile.write(content)
                    except Exception as e:
                        print(f"Error reading {file_path}: {e}")

if __name__ == '__main__':
    main()


================================================================================
File: .\main\ble_task.c
================================================================================

#include "ble_task.h"
#include "hub_ble_gap.h"
#include "hub_ble_gatt.h"
#include "wifi_task.h"

static char *TAG = "BLE Server";
bool is_connected = false;
uint16_t ble_gap_conn_handle = BLE_HS_CONN_HANDLE_NONE;

int ble_gap_event(struct ble_gap_event *event, void *arg)
{
    switch (event->type)
    {
    // Advertise if connected
    case BLE_GAP_EVENT_CONNECT:
        ESP_LOGI(TAG, "BLE GAP EVENT CONNECTION %s", event->connect.status == 0 ? "OK :)" : "FAILED :(");

        if (event->connect.status != 0)
        {
            ESP_LOGE(TAG, "Connection error: %d", event->connect.status);
        } else {
            is_connected = true;
            ble_gap_conn_handle = event->connect.conn_handle;
        }
        // Advertise again
        ble_app_advertise();
        break;
    case BLE_GAP_EVENT_DISCONNECT:
        ESP_LOGI(TAG, "DEVICE DISCONNECTED. RESTARTING ADVERTISING");
        is_connected = false;
        ble_gap_conn_handle = BLE_HS_CONN_HANDLE_NONE;
        ble_app_advertise();
        break;
    default:
        break;
    }
    return 0;
}

void ble_wifi_init()
{
    esp_err_t ret = nvs_flash_init();
    // Intialize NVS
    if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND)
    {
        ESP_ERROR_CHECK(nvs_flash_erase());
        ret = nvs_flash_init();
    }
    ESP_ERROR_CHECK(ret);                            // Check if NVS intialization is successful
    nimble_port_init();                              // Initialize the host stack
    ble_svc_gap_device_name_set("Dave Ble"); // Initialize NimBLE configuration - server name
    ble_svc_gap_init();                              // Initialize NimBLE configuration - gap service
    ble_svc_gatt_init();                             // Initialize NimBLE configuration - gatt service
    ble_gatts_count_cfg(gatt_svcs);                  // Initialize NimBLE configuration - config gatt services
    ble_gatts_add_svcs(gatt_svcs);                   // Initialize NimBLE configuration - queues gatt services.
    ble_hs_cfg.sync_cb = ble_app_on_sync;            // Initialize application
    nimble_port_freertos_init(host_task);            // Run the thread
    while (1)
    {
        if (is_ssid_set && is_pass_set)
        {
            wifi_init();
        }
            ESP_LOGW(TAG, "Waiting for WiFi credentials...");
        vTaskDelay(1000 / portTICK_PERIOD_MS); // delay 1 sec
    }
}

================================================================================
File: .\main\ble_task.h
================================================================================

#ifndef BLE_TASK_H
#define BLE_TASK_H

#include <stdio.h>
#include <stdint.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "nvs_flash.h"
#include "esp_log.h"
#include "nimble/nimble_port.h"
#include "nimble/nimble_port_freertos.h"
#include "host/ble_hs.h"
#include "services/gap/ble_svc_gap.h"
#include "services/gatt/ble_svc_gatt.h"

extern bool is_connected;
extern uint16_t ble_gap_conn_handle;

int ble_gap_event(struct ble_gap_event *event, void *arg);
void ble_wifi_init();

#endif

================================================================================
File: .\main\hub_ble_gap.c
================================================================================

#include "hub_ble_gap.h"

static char* TAG = "BLE Server";
uint8_t ble_addr_type;

// Define BLE Connection
void ble_app_advertise()
{

    // GAP - Device name def
    struct ble_hs_adv_fields adv_fields;
    const char *device_name;
    memset(&adv_fields, 0, sizeof(adv_fields));
    device_name = ble_svc_gap_device_name();
    adv_fields.name = (uint8_t *)device_name;
    adv_fields.name_len = strlen(device_name);
    adv_fields.name_is_complete = 1;
    ble_gap_adv_set_fields(&adv_fields);

    // GAP - Device Connectivity def
    struct ble_gap_adv_params adv_params;
    memset(&adv_params, 0, sizeof(adv_params));
    adv_params.conn_mode = BLE_GAP_CONN_MODE_UND;
    adv_params.disc_mode = BLE_GAP_DISC_MODE_GEN;
    ble_gap_adv_start(ble_addr_type, NULL, BLE_HS_FOREVER, &adv_params, ble_gap_event, NULL);
}

void ble_app_on_sync(void)
{
    ble_hs_id_infer_auto(0, &ble_addr_type);
    ble_app_advertise();
}

void host_task(void *params)
{
    nimble_port_run();
}

================================================================================
File: .\main\hub_ble_gap.h
================================================================================

#ifndef BLE_GAP_H
#define BLE_GAP_H

#include <stdio.h>
#include <stdint.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "nvs_flash.h"
#include "esp_log.h"
#include "nimble/nimble_port.h"
#include "nimble/nimble_port_freertos.h"
#include "host/ble_hs.h"
#include "services/gap/ble_svc_gap.h"
#include "services/gatt/ble_svc_gatt.h"

int ble_gap_event(struct ble_gap_event *event, void *arg);
void ble_app_advertise();
void ble_app_on_sync(void);
void host_task(void *params);

#endif

================================================================================
File: .\main\hub_ble_gatt.c
================================================================================

#include "ble_task.h"
#include "hub_ble_gatt.h"
#include "wifi_task.h"
#include "hub_server_comm.h"
#include "hub_queue.h"

static char *TAG = "BLE HUB";

const struct ble_gatt_svc_def gatt_svcs[] = {
    {.type = BLE_GATT_SVC_TYPE_PRIMARY, // Type of service
     .uuid = BLE_UUID16_DECLARE(0x0180),
     .characteristics = (struct ble_gatt_chr_def[]){
         {// Char for Device id (prefix 1)
          .uuid = BLE_UUID16_DECLARE(0x1234),
          .flags = BLE_GATT_CHR_F_READ | BLE_GATT_CHR_F_WRITE,
          .access_cb = hub_handle_device_id},
         {// Char for Temp data (pref 2)
          .uuid = BLE_UUID16_DECLARE(0x5678),
          .flags = BLE_GATT_CHR_F_READ | BLE_GATT_CHR_F_WRITE,
          .access_cb = hub_handle_temperature_data},
         {// Char for LED command
          .uuid = BLE_UUID16_DECLARE(0x9ABC),
          .flags = BLE_GATT_CHR_F_READ,
          .access_cb = hub_handle_led_command},
         {0} // End of characteristics array
     }},
    {.type = BLE_GATT_SVC_TYPE_PRIMARY, .uuid = BLE_UUID16_DECLARE(0x0185), .characteristics = (struct ble_gatt_chr_def[]){
                                                                                {.uuid = BLE_UUID16_DECLARE(0x4321), .flags = BLE_GATT_CHR_F_WRITE, .access_cb = hub_handle_wifi_ssid_write}, {.uuid = BLE_UUID16_DECLARE(0x8765), .flags = BLE_GATT_CHR_F_WRITE, .access_cb = hub_handle_wifi_password_write}, {0} // End of characteristics array
                                                                            }},
    {0} // End of services array
};

int hub_handle_led_command(uint16_t conn_handle, uint16_t attr_handle, struct ble_gatt_access_ctxt *ctxt, void *arg)
{
    if (conn_handle != BLE_HS_CONN_HANDLE_NONE && has_wifi_connected)
    {

        ESP_LOGI("BLE_GATT", "LED command characteristic read");

        // // Example LED command value to be sent back to the client
        // const char *led_command = "LED:255,0,0";

        ESP_LOGI(TAG, "Trying to send LED command to client");

        int rc = os_mbuf_append(ctxt->om, led_command_buffer, strlen(led_command_buffer));
        ESP_LOGW(TAG, "LED command read by client: %s", led_command_buffer);
        if (rc != 0)
        {
            ESP_LOGE("LED Command", "Failed to send LED command");
            return BLE_ATT_ERR_INSUFFICIENT_RES;
        }

        read_led_command_from_server();

        return 0;
    } else {
        ESP_LOGI("LED Command", "Connection invalid!");
        return -1;
    }
}

int hub_handle_device_id(uint16_t conn_handle, uint16_t attr_handle, struct ble_gatt_access_ctxt *ctxt, void *arg)
{
    ESP_LOGI("BLE_GATT", "Device ID characteristic accessed");
    if (ctxt->om->om_len <= 0)
    {
        ESP_LOGI(TAG, "Empty Device ID received");
        return BLE_ATT_ERR_INVALID_ATTR_VALUE_LEN;
    }
    if (ctxt->op == BLE_GATT_ACCESS_OP_WRITE_CHR)
    {
        if (ctxt->om->om_len == 6)
        {
            uint8_t device_id[6];
            memcpy(device_id, ctxt->om->om_data, 6);
            ESP_LOGI("Device ID", "Received MAC: %02x:%02x:%02x:%02x:%02x:%02x",
                     device_id[0], device_id[1], device_id[2], device_id[3], device_id[4], device_id[5]);
            enqueue_mac_address(device_id);
        }
        else
        {
            ESP_LOGE("Device ID", "Invalid MAC address length received: %d", ctxt->om->om_len);
        }
    }
    memset(ctxt->om->om_data, 0, ctxt->om->om_len); // Clear the buffer
    return 0;
}

int hub_handle_temperature_data(uint16_t conn_handle, uint16_t attr_handle, struct ble_gatt_access_ctxt *ctxt, void *arg)
{

    ESP_LOGI("BLE_GATT", "Temperature characteristic accessed");
    if (ctxt->om->om_len <= 0)
    {
        ESP_LOGE(TAG, "Empty sensor data received");
        return BLE_ATT_ERR_INVALID_ATTR_VALUE_LEN;
    }

    if (ctxt->op == BLE_GATT_ACCESS_OP_WRITE_CHR)
    { // clear the buffer
        char temp[ctxt->om->om_len + 1];
        memcpy(temp, ctxt->om->om_data, ctxt->om->om_len);
        temp[ctxt->om->om_len] = '\0'; // Lägg till null-terminator
        ESP_LOGI("Temperature", "Received: %s °C", temp);
        enqueue_temperature(temp); // Add to queue
    }

    memset(ctxt->om->om_data, 0, ctxt->om->om_len);
    return 0;
}

int hub_handle_wifi_ssid_write(uint16_t conn_handle, uint16_t attr_handle, struct ble_gatt_access_ctxt *ctxt, void *arg)
{
    char temp[ctxt->om->om_len + 1];
    memcpy(temp, ctxt->om->om_data, ctxt->om->om_len);
    temp[ctxt->om->om_len] = '\0'; // Lägg till null-terminator

    set_wifi_ssid(temp);
    ESP_LOGI(TAG, "SSID: %s", get_wifi_ssid());
    return 1;
}

int hub_handle_wifi_password_write(uint16_t conn_handle, uint16_t attr_handle, struct ble_gatt_access_ctxt *ctxt, void *arg)
{
    char temp[ctxt->om->om_len + 1];
    memcpy(temp, ctxt->om->om_data, ctxt->om->om_len);
    temp[ctxt->om->om_len] = '\0'; // Lägg till null-terminator

    set_wifi_password(temp);
    ESP_LOGI(TAG, "Password: %s", get_wifi_password());
    return 1;
}


================================================================================
File: .\main\hub_ble_gatt.h
================================================================================

#ifndef BLE_GATT_H
#define BLE_GATT_H

#include <stdio.h>
#include <stdint.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "nvs_flash.h"
#include "esp_log.h"
#include "nimble/nimble_port.h"
#include "nimble/nimble_port_freertos.h"
#include "host/ble_hs.h"
#include "services/gap/ble_svc_gap.h"
#include "services/gatt/ble_svc_gatt.h"

void dsc_test();

int hub_handle_led_command(uint16_t conn_handle, uint16_t attr_handle, struct ble_gatt_access_ctxt *ctxt, void *arg);

int hub_handle_device_id(uint16_t conn_handle, uint16_t attr_handle, struct ble_gatt_access_ctxt *ctxt, void *arg);
int hub_handle_temperature_data(uint16_t conn_handle, uint16_t attr_handle, struct ble_gatt_access_ctxt *ctxt, void *arg);
//int hub_handle_commands(uint16_t conn_handle, uint16_t attr_handle, struct ble_gatt_access_ctxt *ctxt, void *arg);
int hub_handle_wifi_ssid_write(uint16_t conn_handle, uint16_t attr_handle, struct ble_gatt_access_ctxt *ctxt, void *arg);
int hub_handle_wifi_password_write(uint16_t conn_handle, uint16_t attr_handle, struct ble_gatt_access_ctxt *ctxt, void *arg);

extern const struct ble_gatt_svc_def gatt_svcs[];
#endif

================================================================================
File: .\main\hub_main.c
================================================================================

#include "hub_ble_gap.h"
#include "hub_ble_gatt.h"
#include "ble_task.h"
#include "hub_queue.h"
#include "hub_server_comm.h"

void app_main(void)
{
    // Initialize the queue for sending data
    init_queue();

    xTaskCreate(ble_wifi_init, "ble_wifi_init", 4096, NULL, 5, NULL);
    
    vTaskDelay(pdMS_TO_TICKS(500)); // Delay between BLE and WiFi init to allow things to stabilize.
    // Start the queue processing task
    xTaskCreate(process_queue_task, "process_queue_task", 4096, NULL, 2, NULL);


    // Initialize BLE and WiFi

    while (1)
    {
        // Read LED command from the Go server every 10 seconds
        read_led_command_from_server();
        vTaskDelay(pdMS_TO_TICKS(10000)); // Wait for 10 seconds
    }
}

================================================================================
File: .\main\hub_queue.c
================================================================================

#include "hub_queue.h"
#include "hub_server_comm.h"

const char* TAG = "HUB-QUEUE";

QueueHandle_t data_queue = NULL;

void init_queue(){
    data_queue = xQueueCreate(QUEUE_LENGTH, sizeof(queue_item_t)); //Queue for data, size defined in header
    if(data_queue == NULL){
        ESP_LOGE("QUEUE", "Failed to create queue");
    }
}
void process_queue_task(void* pvParameters) {
    queue_item_t item;
    while (1) {
    //check if wifi is init

    if (has_wifi_connected) {
        if (xQueueReceive(data_queue, &item, portMAX_DELAY) == pdPASS) {
            switch (item.action_type) {
                case ACTION_SEND_TEMPERATURE:
                    //Handle temp data
                    ESP_LOGI(TAG, "Sending temperature: %s", item.data.temperature);
                    send_to_server(PREFIX_SENSOR_DATA, item.data.temperature);
                    break;
                case ACTION_SEND_MAC_ADDRESS:
                    //Handle mac address
                    char mac_str[18];
                    snprintf(mac_str, sizeof(mac_str), "%02x:%02x:%02x:%02x:%02x:%02x", 
                            item.data.mac_address[0], item.data.mac_address[1], item.data.mac_address[2], 
                            item.data.mac_address[3], item.data.mac_address[4], item.data.mac_address[5]);
                    ESP_LOGW(TAG, "Sending MAC address: %s", mac_str);
                    send_to_server(PREFIX_REGISTER, mac_str);
                    break;
                default:
                    ESP_LOGE(TAG, "Unknown action type: %d", item.action_type);
                    break;
            }
            //Maybe close connection here
            // close_connection();
    }
        } else {
            vTaskDelay(100 / portTICK_PERIOD_MS);  // Wait for a second before checking again
        }
    }
}
void enqueue_temperature(const char* temperature) {
    ESP_LOGW(TAG, "Enqueuing temperature data");
    ESP_LOGW(TAG, "WIFICONNECTED: %d", has_wifi_connected);
    queue_item_t item;
    item.action_type = ACTION_SEND_TEMPERATURE;
    
    // Copy temperature data to item (strncpy ensures no buffer overflow)
    strncpy(item.data.temperature, temperature, sizeof(item.data.temperature) - 1);
    item.data.temperature[sizeof(item.data.temperature) - 1] = '\0'; // Null-terminate

    if (xQueueSend(data_queue, &item, 100 / portTICK_PERIOD_MS) != pdPASS) {
        // Queue is full, check if we can discard the oldest item (only temperature)
        ESP_LOGW(TAG, "Queue is full, checking oldest item");

        queue_item_t oldest_item;
        if (xQueuePeek(data_queue, &oldest_item, 0) == pdPASS) {
            // Check if the oldest item is temperature data
            if (oldest_item.action_type == ACTION_SEND_TEMPERATURE) {
                // Discard the oldest temperature data
                ESP_LOGW(TAG, "Discarding oldest temperature data");
                xQueueReceive(data_queue, &oldest_item, 0); // Remove the oldest item

                // Now try sending the new item again
                if (xQueueSend(data_queue, &item, 100 / portTICK_PERIOD_MS) != pdPASS) {
                    ESP_LOGE(TAG, "Failed to enqueue temperature data after discarding oldest");
                } else {
                    ESP_LOGI(TAG, "Temperature data enqueued after discarding oldest");
                }
            } else {
                ESP_LOGW(TAG, "Oldest item is not temperature data, skipping enqueue");
            }
        }
    } else {
        ESP_LOGW(TAG, "Temperature data enqueued");
    } 
}

void enqueue_mac_address(const uint8_t* mac_address) {
    ESP_LOGW(TAG, "Enqueuing MAC address");
    ESP_LOGW(TAG, "WIFICONNECTED: %d", has_wifi_connected);
    queue_item_t item;
    item.action_type = ACTION_SEND_MAC_ADDRESS;
    
    memcpy(item.data.mac_address, mac_address, 6);

    // Try to enqueue the MAC address
    if (xQueueSend(data_queue, &item, 100 / portTICK_PERIOD_MS) != pdPASS) {
        ESP_LOGW(TAG, "Queue is full, checking oldest item");

        queue_item_t oldest_item;
        // Peek to see the oldest item in the queue
        if (xQueuePeek(data_queue, &oldest_item, 0) == pdPASS) {
            // Check if the oldest item is temperature data
            if (oldest_item.action_type == ACTION_SEND_TEMPERATURE) {
                // Discard the oldest temperature data
                ESP_LOGW(TAG, "Discarding oldest temperature data to enqueue MAC address");
                xQueueReceive(data_queue, &oldest_item, 0); // Remove the oldest temperature item

                // Now try to enqueue the MAC address again
                if (xQueueSend(data_queue, &item, 100 / portTICK_PERIOD_MS) != pdPASS) {
                    ESP_LOGE(TAG, "Failed to enqueue MAC address after discarding oldest");
                } else {
                    ESP_LOGI(TAG, "MAC address enqueued after discarding oldest temperature data");
                }
            } else {
                ESP_LOGE(TAG, "Queue is full, but oldest item is not temperature data. Could not enqueue MAC address.");
            }
        } else {
            ESP_LOGE(TAG, "Failed to peek into queue.");
        }
    } else {
        ESP_LOGI(TAG, "MAC address enqueued");
    }
}


================================================================================
File: .\main\hub_queue.h
================================================================================

#ifndef HUB_QUEUE_H
#define HUB_QUEUE_H

#include "freertos/FreeRTOS.h"
#include "freertos/queue.h"
#include "esp_log.h"
#include "wifi_task.h"

#define QUEUE_LENGTH 30



typedef enum {
    ACTION_SEND_TEMPERATURE,
    ACTION_SEND_MAC_ADDRESS
} action_type_t;

typedef struct {
    action_type_t action_type; // type of data
    union {
        //temp and mac address
        char temperature[32];
        uint8_t mac_address[6];
    } data;
} queue_item_t;

void init_queue();
void process_queue_task(void* pvParameters);
void enqueue_temperature(const char* temperature);
void enqueue_mac_address(const uint8_t* mac_address);


#endif

================================================================================
File: .\main\hub_server_comm.c
================================================================================

#include "hub_server_comm.h"
#include "ble_task.h"
#include "hub_ble_gatt.h"
#include "wifi_task.h"

static const char *TAG = "HUB-TCP";
static int sock = -1;                      // Persistent socket for communication
char led_command_buffer[64] = "LED:0,0,0"; // Buffer for the LED command, default value is "LED:0,0,0"
//int tcp_connected = 0;  // Initially, not connected


// Initialize a TCP connection to the server
static bool connect_to_server() {
    ESP_LOGI(TAG, "Attempting to connect to server");

    struct sockaddr_in server_addr;

    // Close and reset the socket if it was previously open
    if (sock != -1) {
        ESP_LOGW(TAG, "Closing existing socket");
        close(sock);
        sock = -1;
    }

    // Create a new socket
    sock = socket(AF_INET, SOCK_STREAM, 0);
    if (sock < 0) {
        ESP_LOGE(TAG, "Failed to create socket");
        return false;
    }

    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(SERVER_PORT);
    if (inet_pton(AF_INET, SERVER_IP, &server_addr.sin_addr) <= 0) {
        ESP_LOGE(TAG, "Invalid server address");
        close(sock);
        sock = -1;
        return false;
    }

    // Attempt to connect
    if (connect(sock, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0) {
        ESP_LOGE(TAG, "Failed to connect to server");
        close(sock);
        sock = -1;
        return false;
    }

    ESP_LOGI(TAG, "Connected to server: %s:%d", SERVER_IP, SERVER_PORT);
    return true;
}


bool connect_to_server_with_retries(int retries, int delay_ms) {
    for (int i = 0; i < retries; i++) {
        if (connect_to_server()) {
            return true;
        }
        ESP_LOGW(TAG, "Retrying connection... (%d/%d)", i + 1, retries);
        vTaskDelay(delay_ms / portTICK_PERIOD_MS);
    }
    ESP_LOGE(TAG, "Failed to connect to server after %d retries", retries);
    return false;
}
// Read data (Led command) from the the GO server
void read_led_command_from_server()
{
    if (ble_gap_conn_handle != BLE_HS_CONN_HANDLE_NONE && has_wifi_connected)
    {

        ESP_LOGI(TAG, "IN BEGINNING READ LED FUNCCCCCC");

        if (!connect_to_server_with_retries(5, 1000))
        {
            ESP_LOGE(TAG, "Failed to connect to server");
            return;
        }
        ESP_LOGI(TAG, "IN READ LED FUNCCCCCC");
        char recv_buffer[64];
        int len = recv(sock, recv_buffer, sizeof(recv_buffer) - 1, 0);
        ESP_LOGI(TAG, "AFTER RECEIVEVEVEVEVEVEVEVEV");
        if (len > 0)
        {
            recv_buffer[len] = 0; // Null-terminate received data
            ESP_LOGI(TAG, "Received command from server: %s", recv_buffer);

            // store the received command in the global buffer for ble clients
            strncpy(led_command_buffer, recv_buffer, sizeof(led_command_buffer) - 1);
            led_command_buffer[sizeof(led_command_buffer) - 1] = 0; // Null-terminate the buffer
        }
        else if (len == 0)
        {
            ESP_LOGE(TAG, "Server closed the connection");
            close(sock);
            sock = -1;
        }
        else
        {
            ESP_LOGE(TAG, "Failed to receive data");
            close(sock);
            sock = -1;
        }
    }
}

// Send data to the server
void send_to_server(int prefix, const char *data)
{
    if (!connect_to_server())
    {
        ESP_LOGE(TAG, "Failed to connect to server");
        return;
    }

    // Prepare the message with the prefix
    char message[256];
    int msg_len = snprintf(message, sizeof(message), "%d%s", prefix, data);

    // Send the message
    int bytes_sent = send(sock, message, msg_len, 0);
    if (bytes_sent < 0)
    {
        ESP_LOGE(TAG, "Failed to send data, attempting to reconnect...");
        close(sock);
        sock = -1;

        // Try to reconnect and resend the data
        if (!connect_to_server())
        {
            ESP_LOGE(TAG, "Reconnection failed");
            return;
        }

        bytes_sent = send(sock, message, msg_len, 0);
        if (bytes_sent < 0)
        {
            ESP_LOGE(TAG, "Failed to send data after reconnection");
            close(sock);
            sock = -1;
            return;
        }
    }

    ESP_LOGI(TAG, "Data sent: %s", message);

    // Receive response from the server (optional)
    char recv_buffer[128];
    int len = recv(sock, recv_buffer, sizeof(recv_buffer) - 1, 0);
    if (len > 0)
    {
        recv_buffer[len] = 0; // Null-terminate received data
        ESP_LOGI(TAG, "Received from server: %s", recv_buffer);
    }
    else if (len == 0)
    {
        ESP_LOGE(TAG, "Server closed the connection");
        close(sock);
        sock = -1;
    }
    else
    {
        ESP_LOGE(TAG, "Failed to receive data");
        close(sock);
        sock = -1;
    }
}

// Close the persistent connection when needed
void close_connection()
{
    if (sock != -1)
    {
        close(sock);
        sock = -1;
        ESP_LOGI(TAG, "Connection closed");
    }
}


================================================================================
File: .\main\hub_server_comm.h
================================================================================

#ifndef HUB_SERVER_COMM_H
#define HUB_SERVER_COMM_H

#define SERVER_IP "83.23.160.146" //ändra till dator ip
#define SERVER_PORT 8080

#define PREFIX_REGISTER 1
#define PREFIX_SENSOR_DATA 2
#define PREFIX_COMMAND 3

#include "lwip/sockets.h"
#include "esp_log.h"

extern char led_command_buffer[64];
extern int tcp_connected;

bool connect_to_server_with_retries(int retries, int delay_ms);

void read_led_command_from_server();

void send_to_server(int prefix, const char *data);

void close_connection();

#endif

================================================================================
File: .\main\wifi_task.c
================================================================================

#include "wifi_task.h"
#include <stdbool.h>

bool is_ssid_set = false;
bool is_pass_set = false;
bool has_wifi_init = false;
bool has_wifi_connected = false;

static const char* TAG = "WIFI";

wifi_config_t wifi_config = {
    .sta = {
        .ssid = {0},
        .password = {0},
        .threshold.authmode = WIFI_AUTH_WPA2_PSK,
    },
};


// Event handler for WiFi and IP events
void wifi_event_handler(void* arg, esp_event_base_t event_base, int32_t event_id, void* event_data) {
    if (event_base == WIFI_EVENT && event_id == WIFI_EVENT_STA_START) {
        esp_wifi_connect();  // Connect when WiFi starts
        ESP_LOGI(TAG, "WiFi started, attempting to connect...");
    } else if (event_base == WIFI_EVENT && event_id == WIFI_EVENT_STA_DISCONNECTED) {
        has_wifi_connected = false;  // Mark as disconnected
        ESP_LOGI(TAG, "WiFi disconnected, reconnecting...");
        esp_wifi_connect();  // Reconnect automatically
    } else if (event_base == IP_EVENT && event_id == IP_EVENT_STA_GOT_IP) {
        has_wifi_connected = true;  // Mark as connected
        ip_event_got_ip_t* event = (ip_event_got_ip_t*) event_data;
        ESP_LOGI(TAG, "Got IP: " IPSTR, IP2STR(&event->ip_info.ip));
        ESP_LOGI(TAG, "Subnet mask: " IPSTR, IP2STR(&event->ip_info.netmask));
        ESP_LOGI(TAG, "Gateway: " IPSTR, IP2STR(&event->ip_info.gw));
    }
}

void wifi_init()
{
    static esp_netif_t* netif = NULL;
    // if first time, initialize NVS
    if (!has_wifi_init)
    {
        ESP_ERROR_CHECK(esp_netif_init());
        ESP_ERROR_CHECK(esp_event_loop_create_default());

        netif = esp_netif_create_default_wifi_sta();
        if (netif == NULL)
        {
            ESP_LOGE("WIFI", "Failed to create default wifi netif");
            return;
        }

        wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();
        ESP_ERROR_CHECK(esp_wifi_init(&cfg));

        //register event handler
        ESP_ERROR_CHECK(esp_event_handler_register(WIFI_EVENT, ESP_EVENT_ANY_ID, &wifi_event_handler, NULL));
        ESP_ERROR_CHECK(esp_event_handler_register(IP_EVENT, IP_EVENT_STA_GOT_IP, &wifi_event_handler, NULL));

        ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA));
        ESP_ERROR_CHECK(esp_wifi_set_config(ESP_IF_WIFI_STA, &wifi_config));
        ESP_ERROR_CHECK(esp_wifi_start());

        has_wifi_init = true;
    }
    else
    {
        ESP_LOGI("WIFI", "Reconnecting with new config...");
        esp_wifi_disconnect();
        ESP_ERROR_CHECK(esp_wifi_set_config(ESP_IF_WIFI_STA, &wifi_config));
        ESP_ERROR_CHECK(esp_wifi_connect());
        has_wifi_connected = false;
    }


    ESP_LOGI("WIFI", "SSID: %s", wifi_config.sta.ssid);
    ESP_LOGI("WIFI", "Password: %s", wifi_config.sta.password);

//     ESP_ERROR_CHECK(esp_wifi_connect());

//     esp_netif_ip_info_t ip_info;
//     int retries = 0;
//     const int max_retries = 10;

//     // wait for connection
//     while (retries < max_retries)
//     {
//         ESP_ERROR_CHECK(esp_netif_get_ip_info(netif, &ip_info));
//         if (ip_info.ip.addr != 0)
//         {
//             ESP_LOGI("WIFI", "IP Address: " IPSTR, IP2STR(&ip_info.ip));
//             ESP_LOGI("WIFI", "Subnet mask: " IPSTR, IP2STR(&ip_info.netmask));
//             ESP_LOGI("WIFI", "Gateway: " IPSTR, IP2STR(&ip_info.gw));
//             is_ssid_set = false;
//             is_pass_set = false;
//             //has_wifi_connected = true;
//             ESP_LOGE("WIFI", "WIFI CONNECTED: %d", has_wifi_connected);
//             break;
//         }
//         ESP_LOGI("WIFI", "Waiting for IP... %d", retries);
//         vTaskDelay(pdMS_TO_TICKS(1000)); // wait 1 sec
//         retries++;
//     }

//     if (retries >= max_retries)
//     {
//         ESP_LOGE("WIFI", "Failed to connect to AP after %d retries", max_retries);
//     }
//     // LOGGA
}

void set_wifi_ssid(const char *ssid)
{
    strncpy((char *)wifi_config.sta.ssid, ssid, sizeof(wifi_config.sta.ssid));
    is_ssid_set = true;
}

void set_wifi_password(const char *password)
{
    strncpy((char *)wifi_config.sta.password, password, sizeof(wifi_config.sta.password));
    is_pass_set = true;
}

const char *get_wifi_ssid()
{
    return (const char *)wifi_config.sta.ssid;
}

const char *get_wifi_password()
{
    return (const char *)wifi_config.sta.password;
}

================================================================================
File: .\main\wifi_task.h
================================================================================

#ifndef WIFI_TASK_H
#define WIFI_TASK_H

#include <string.h>
#include <stdbool.h>
#include "esp_wifi.h"
#include "esp_event.h"
#include "esp_netif.h"
#include "esp_log.h"
#include "nvs_flash.h"

extern bool is_ssid_set;
extern bool is_pass_set;
extern bool has_wifi_init;
extern bool has_wifi_connected;
extern wifi_config_t wifi_config;

void wifi_init();
void set_wifi_ssid(const char* ssid);
void set_wifi_password(const char* password);
const char* get_wifi_ssid();
const char* get_wifi_password();

#endif